<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizations 3-0 Decks</title>
    <style>
        .chart-container {
            margin-bottom: 40px;
        }

        .chart-row {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin-bottom: 40px;
        }

        .chart {
            flex: 1;
            min-width: 45%;
            margin: 10px;
        }

        .full-width {
            width: 99%;
        }

        .chart .plotly {
            border-radius: 10px;
            clip-path: inset(0 round 10px); /* Ensures rounded edges */
        }
    </style>
    <link rel="stylesheet" href="../css/analysisStyles.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>

    <h1>3-0 Decks Statistics</h1>

    <p>
    Note: 
    <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
        <mi>Percentage&nbsp;of&nbsp;cards</mi>
        <mo>=</mo>
        <mfrac>
            <mrow>
            <mi>Number&nbsp;of&nbsp;qualifying&nbsp;cards&nbsp;in&nbsp;class&nbsp;decks</mi>
            </mrow>
            <mrow>
            <mi>Total&nbsp;cards&nbsp;in&nbsp;all&nbsp;class&nbsp;decks</mi>
            <mo>-</mo>
            <mi>equipment&nbsp;and&nbsp;unplayable&nbsp;cards</mi>
            </mrow>
        </mfrac>
        <mo>&times;</mo>
        <mn>100</mn>
        </mrow>
    </math>
    </p>
      
    <div class="chart-container">
        <h2>Number of recorded decks</h2>
        <div id="deck-statistics-1" class="chart full-width"></div>
    </div>

    <div class="chart-container">
        <h2>Pitch Distribution & Defense Distribution</h2>
        <div class="chart-row">
            <div id="pitch-distribution" class="chart"></div>
            <div id="defense-distribution" class="chart"></div>
        </div>
    </div>

    <div class="chart-container">
        <h2>Cost Distribution & Card Types</h2>
        <div class="chart-row">
            <div id="cost-distribution" class="chart"></div>
            <div id="card-types" class="chart"></div>
        </div>
    </div>

    <div class="chart-container">
        <h2>Shared Cards by Rarity + Equipment</h2>
        <div id="cards-classification" class="chart full-width"></div>
    </div>

    <div class="chart-container">
        <h2>Number of specified cards in deck</h2>
        <p>Note: Cumulative Increase represents the graphical visualization of the calculation of discrete expected value.</p>
        <div id="number-of-cards" class="chart full-width"></div>
    </div>

    <script>
        // Function to support dark mode
        function applyDarkModeStyles(layout) {
            const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark";

            return {
                ...layout, // Preserve existing layout settings
                paper_bgcolor: isDarkMode ? "#1e1e1e" : "#f4f4f4",
                plot_bgcolor: isDarkMode ? "#222" : "#fff",
                font: { color: isDarkMode ? "#eee" : "#000" },
                xaxis: {
                    ...layout.xaxis, // Preserve existing x-axis settings
                    gridcolor: isDarkMode ? "#444" : "#ddd",
                    zerolinecolor: isDarkMode ? "#666" : "#bbb",
                    linecolor: isDarkMode ? "#aaa" : "#000",
                    tickcolor: isDarkMode ? "#aaa" : "#000"
                },
                yaxis: {
                    ...layout.yaxis, // Preserve existing y-axis settings
                    gridcolor: isDarkMode ? "#444" : "#ddd",
                    zerolinecolor: isDarkMode ? "#666" : "#bbb",
                    linecolor: isDarkMode ? "#aaa" : "#000",
                    tickcolor: isDarkMode ? "#aaa" : "#000"
                }
            };
        }

        // Function to fetch and render a chart
        function renderChart(containerId, dataFile) {
            fetch(dataFile)
                .then(response => response.json())
                .then(data => {
                    const updatedLayout = applyDarkModeStyles(data.layout);
                    Plotly.newPlot(containerId, data.data, updatedLayout);
                })
                .catch(error => {
                    console.error('Error loading chart data:', error);
                });
        }

        // Initial load and render for all charts
        renderChart('deck-statistics-1', './vis_data/deck_statistics.json');
        renderChart('pitch-distribution', './vis_data/pitch_distribution.json');
        renderChart('defense-distribution', './vis_data/defense_distribution.json');
        renderChart('cost-distribution', './vis_data/cost_distribution.json');
        renderChart('card-types', './vis_data/card_types_keywords.json');

        // Render common cards initially
        renderChart('cards-classification', './vis_data/equipment_comparison_classes.json');

        // Function to update the common/rare/mythic cards chart
        function updateCardsChart(containerId, dataFile, group) {
            fetch(dataFile)
                .then(response => response.json())
                .then(data => {
                    if (dataFile === './vis_data/equipment_comparison_classes.json') {
                        data.layout.yaxis.title = "Percentage of equipments";
                    } else {
                        data.layout.yaxis.title = "Percentage of cards";
                    }
                    let chartData = data.data;
                    if (group !== 'All') {
                        // Find the selected group data
                        const selectedData = data.data.find(trace => trace.name === group);
                        if (selectedData) {
                            chartData = [selectedData];

                            // Sorting
                            let combinedData = chartData[0].x.map((x, i) => {
                                return { x: x, y: chartData[0].y[i] };
                            });

                            combinedData.sort((a, b) => b.y - a.y);

                            chartData[0].x = combinedData.map(data => data.x);
                            chartData[0].y = combinedData.map(data => data.y);
                        }
                    }
                    const updatedLayout = applyDarkModeStyles(data.layout);
                    Plotly.react(containerId, chartData, updatedLayout);
                })
                .catch(error => {
                    console.error('Error loading chart data:', error);
                });
        }

        const cardClassificationContainer = document.getElementById('cards-classification');
        const chartDropdown = document.createElement('select');
        const groupDropdown = document.createElement('select');

        const chartOptions = [
            { value: 'equipment', text: 'Equipment Cards', file: './vis_data/equipment_comparison_classes.json' },
            { value: 'pure_draconic_cards', text: 'Pure Draconic Cards', file: './vis_data/pure_draconic_cards.json' },
            { value: 'ninja_assassin_cards', text: 'Ninja/Assassin Cards', file: './vis_data/ninja_assassin_cards.json' },
            { value: 'warrior_assassin_cards', text: 'Warrior/Assassin Cards', file: './vis_data/warrior_assassin_cards.json' },
            { value: 'generic_cards', text: 'Generic Cards', file: './vis_data/generic_cards.json' }
        ];

        chartOptions.forEach(optionData => {
            const option = document.createElement('option');
            option.value = optionData.value;
            option.text = optionData.text;
            chartDropdown.appendChild(option);
        });

         // Populate group dropdown
         const groupOptions = [
            { value: 'All', text: 'All' },
            { value: 'Fang', text: 'Fang' },
            { value: 'Cindra', text: 'Cindra' },
            { value: 'Arakni, Web of Deceit', text: 'Arakni, Web of Deceit' },
        ];

        groupOptions.forEach(optionData => {
            const option = document.createElement('option');
            option.value = optionData.value;
            option.text = optionData.text;
            groupDropdown.appendChild(option);
        });

        cardClassificationContainer.parentNode.insertBefore(chartDropdown, cardClassificationContainer);
        cardClassificationContainer.parentNode.insertBefore(groupDropdown, cardClassificationContainer);

        // Add onchange event for chartDropdown
        chartDropdown.onchange = function () {
            updateCardsChart('cards-classification', chartOptions.find(option => option.value === this.value).file, groupDropdown.value);
        };

        // Add onchange event for groupDropdown
        groupDropdown.onchange = function () {
            updateCardsChart('cards-classification', chartOptions.find(option => option.value === chartDropdown.value).file, this.value);
        };

        // Initial render based on default dropdown values
        updateCardsChart('cards-classification', './vis_data/equipment_comparison_classes.json', 'All');

        // Line charts
        function updateCardsByTypeChart(type, mode) {
            const fileMap = {
                'red': './vis_data/number_of_red_cards.json',
                'yellow': './vis_data/number_of_yellow_cards.json',
                'blue': './vis_data/number_of_blue_cards.json',
                'draconic': './vis_data/number_of_draconic_cards.json',
                'warrior': './vis_data/number_of_warrior_cards.json',
                'ninja': './vis_data/number_of_ninja_cards.json',
                'assassin': './vis_data/number_of_assassin_cards.json',
                'generic': './vis_data/number_of_generic_cards.json',
                'equipment': './vis_data/number_of_equipment_cards.json',
                'non-equipment': './vis_data/number_of_non-equipment_cards.json',
                'all': './vis_data/number_of_all_cards.json'
            };
            fetch(fileMap[type])
                .then(response => response.json())
                .then(data => {
                    if (mode === 'cumulative') {
                        data.layout.yaxis.title = 'Expected Value: Cumulative Increase';
                        data.data.forEach(trace => {
                            let cumulativeY = [];
                            let cumulativeSum = 0;
                            trace.y.forEach((value, index) => {
                                cumulativeSum += trace.x[index] * value / 100;
                                cumulativeY.push(cumulativeSum);
                            });
                            trace.y = cumulativeY;
                        });
                    } else {
                        data.layout.yaxis.title = 'Percentage of decks';
                    }
                    const updatedLayout = applyDarkModeStyles(data.layout);
                    Plotly.react('number-of-cards', data.data, updatedLayout);
                })
                .catch(error => {
                    console.error('Error loading chart data:', error);
                });
        }

        // Add dropdown for cards by type and percentage/cumulative mode
        const numberOfCardsContainer = document.getElementById('number-of-cards');
        const typeDropdown = document.createElement('select');
        const modeDropdown = document.createElement('select');

        typeDropdown.onchange = function () {
            updateCardsByTypeChart(this.value, modeDropdown.value);
        };

        modeDropdown.onchange = function () {
            updateCardsByTypeChart(typeDropdown.value, this.value);
        };

        const typeOptions = [
            { value: 'red', text: 'Red Cards' },
            { value: 'yellow', text: 'Yellow Cards' },
            { value: 'blue', text: 'Blue Cards' },
            { value: 'draconic', text: 'Draconic Cards' },
            { value: 'warrior', text: 'Warrior Cards' },
            { value: 'ninja', text: 'Ninja Cards' },
            { value: 'assassin', text: 'Assassin Cards' },
            { value: 'generic', text: 'Generic Cards' },
            { value: 'equipment', text: 'Equipment Cards' },
            { value: 'non-equipment', text: 'Non-Equipment Cards' },
            { value: 'all', text: 'All Cards' }
        ];

        const modeOptions = [
            { value: 'percentage', text: 'Percentage' },
            { value: 'cumulative', text: 'Cumulative Increase' }
        ];

        typeOptions.forEach(optionData => {
            const option = document.createElement('option');
            option.value = optionData.value;
            option.text = optionData.text;
            typeDropdown.appendChild(option);
        });

        modeOptions.forEach(optionData => {
            const option = document.createElement('option');
            option.value = optionData.value;
            option.text = optionData.text;
            modeDropdown.appendChild(option);
        });

        numberOfCardsContainer.parentNode.insertBefore(typeDropdown, numberOfCardsContainer);
        numberOfCardsContainer.parentNode.insertBefore(modeDropdown, numberOfCardsContainer);

        // Render the initial cards by type chart with default type and mode
        updateCardsByTypeChart('red', 'percentage');
    </script>
    <script type="module">
        // Dark-theme for charts
        function applyPlotlyTheme(theme) {
            const isDarkMode = theme === "dark";
            
            const plotConfig = {
                paper_bgcolor: isDarkMode ? "#1e1e1e" : "#f4f4f4", // Chart background
                plot_bgcolor: isDarkMode ? "#222" : "#fff", // Plot area background
                font: {
                    color: isDarkMode ? "#eee" : "#000" // Text color
                },
            };

            document.querySelectorAll(".chart").forEach(chart => {
                Plotly.relayout(chart, plotConfig);
            });
        }

        // Listen for theme changes
        addEventListener("storage", (event) => {
            if (event.key === "theme") {
                applyPlotlyTheme(event.newValue)
                document.documentElement.setAttribute("data-theme", localStorage.getItem("theme"));
            }
        });

        // Apply Theme on Page Load After Ensuring Charts are Initialized
        document.addEventListener("DOMContentLoaded", () => {
            document.documentElement.setAttribute("data-theme", localStorage.getItem("theme"));
            //setTimeout(() => applyPlotlyTheme(localStorage.getItem("theme")), 300); // Small delay to ensure charts exist
        });
    </script>
</body>
</html>
